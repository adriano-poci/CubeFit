diff --git a/CubeFit/kaczmarz_solver.py b/CubeFit/kaczmarz_solver.py
--- a/CubeFit/kaczmarz_solver.py
+++ b/CubeFit/kaczmarz_solver.py
@@ -18,6 +18,7 @@
 from typing import Optional, Tuple
 import numpy as np
 import time
+from tqdm import tqdm
 
 try:
     from threadpoolctl import threadpool_limits
@@ def solve_global_kaczmarz(reader, cfg: SolverCfg, orbit_weights: Optional[np.ndarray] = None,
-    with _blas_ctx(cfg.blas_threads):
-        for ep in range(cfg.epochs):
-            if cfg.verbose:
-                print(f"[Kaczmarz] epoch {ep+1}/{cfg.epochs}")
+    with _blas_ctx(cfg.blas_threads):
+        for ep in range(cfg.epochs):
+            # Epoch header (kept, matches your logs)
+            if cfg.verbose:
+                print(f"[Kaczmarz] epoch {ep+1}/{cfg.epochs}")
+            # Perâ€‘epoch progress bar over spaxels
+            pbar = tqdm(
+                total=reader.nSpat,
+                desc=f"[Kaczmarz] epoch {ep+1}/{cfg.epochs}",
+                unit="spax",
+                dynamic_ncols=True,
+                leave=(ep == cfg.epochs - 1),
+                disable=not cfg.verbose,
+            )
             # iterate spaxels in small tiles to preserve locality if s_tile>1
             for s0, s1 in reader.spaxel_tiles():
                 for s in range(s0, s1):
                     A_f32, y = reader.read_spaxel_plane(s)    # (N,L_eff) float32, (L_eff,) float64
                     L_eff = A_f32.shape[1]
                     K = min(cfg.pixels_per_aperture, L_eff)
@@
                     for l in idx:
                         # Promote only this row to float64 for math
                         a = A_f32[:, l].astype(np.float64, copy=False)  # promote *only* this row
                         if w is not None:
                             a = a * w
                         r = y[l] - np.dot(a, x)          # residual
                         denom = np.dot(a, a) + 1e-18     # safe
                         x += cfg.lr * (r / denom) * a
+                    # update bar once per spaxel
+                    pbar.update(1)
 
-            if cfg.project_nonneg:
+            if cfg.project_nonneg:
                 np.maximum(x, 0, out=x)
+            # close bar at end of epoch
+            pbar.close()
 
     elapsed = time.perf_counter() - t0
     stats = {
