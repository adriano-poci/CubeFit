--- kaczmarz_solver.py
+++ kaczmarz_solver.py
@@ -68,7 +68,11 @@
 def solve_global_kaczmarz(reader,
                           cfg,
                           orbit_weights: Optional[np.ndarray] = None,
-                          x0: Optional[np.ndarray] = None) -> Tuple[np.ndarray, dict]:
+                          x0: Optional[np.ndarray] = None,
+                          orbit_targets: Optional[np.ndarray] = None,
+                          enforce_orbit_mass: str = "off",
+                          penalty_lambda: float = 0.0,
+                          penalty_rate: float = 0.0) -> Tuple[np.ndarray, dict]:
     """
     Streaming, memory-lean Kaczmarz (global NNLS) that:
       * Loads one spaxel plane (N, L_eff) at a time from the reader,
@@ -92,6 +96,21 @@
 
     rng = np.random.default_rng(getattr(cfg, "seed", None))
     N = int(reader.nComp) * int(reader.nPop)
+    C = int(reader.nComp); P = int(reader.nPop)
+    # Prepare orbit mass targets (per-component) if requested
+    w_targets = None
+    if enforce_orbit_mass.lower().startswith("pen") and orbit_targets is not None:
+        ow = np.asarray(orbit_targets, dtype=np.float64).ravel()
+        if ow.size == C:
+            w_targets = ow
+        elif ow.size == C*P:
+            w_targets = ow.reshape(C, P).sum(axis=1)
+        else:
+            raise ValueError(f"orbit_targets must have length C or C*P (got {ow.size}, C={C}, P={P})")
+    # Precompute for penalty updates
+    _penalty_on = (enforce_orbit_mass.lower().startswith("pen") and (penalty_rate > 0.0) and (penalty_lambda > 0.0) and (w_targets is not None))
+    _penalty_norm2 = float(P)  # ||a_c||^2 for a row of ones across P entries
+
 
     # Expand optional per-component weights to length N if needed
     w: Optional[np.ndarray] = None
@@ -165,6 +184,32 @@
                         r = y[l] - np.dot(a64, x)
                         denom = np.dot(a64, a64) + 1e-18
                         x += lr * (r / denom) * a64
+                        # Penalty row update (softly match component mass to orbit_targets)
+                        if _penalty_on and (rng.random() < float(penalty_rate)):
+                            c_idx = int(rng.integers(0, C))
+                            s0_c = c_idx * P
+                            s1_c = s0_c + P
+                            mass_c = float(np.sum(x[s0_c:s1_c]))
+                            r_c = mass_c - float(w_targets[c_idx])
+                            step = lr * (penalty_lambda * r_c / (_penalty_norm2 + 1e-18))
+                            x[s0_c:s1_c] -= step
+                            if proj_nn:
+                                np.maximum(x[s0_c:s1_c], 0, out=x[s0_c:s1_c])
+
+                        # Penalty row update (softly match component mass to orbit_targets)
+                        if _penalty_on and (rng.random() < float(penalty_rate)):
+                            c_idx = int(rng.integers(0, C))
+                            # slice for component c
+                            ofs = c_idx * P
+                            s_c = float(x[ofs:ofs+P].sum())
+                            err = s_c - float(w_targets[c_idx])
+                            # Kaczmarz step on a row of ones with target w_c, scaled by penalty_lambda
+                            step = lr * (penalty_lambda * err / (_penalty_norm2 + 1e-18))
+                            if step != 0.0:
+                                x[ofs:ofs+P] -= step  # subtract because err = sum(x_c)-w_c
+                            if proj_nn:
+                                # keep nonnegativity after penalty adjustment
+                                np.maximum(x[ofs:ofs+P], 0.0, out=x[ofs:ofs+P])
 
                     pbar.update(1)
 
@@ -180,5 +225,8 @@
         "pixels_per_aperture": K_req,
         "blas_threads": blas_threads,
         "N": N,
+        "enforce_orbit_mass": enforce_orbit_mass,
+        "penalty_lambda": penalty_lambda,
+        "penalty_rate": penalty_rate,
     }
     return x, stats